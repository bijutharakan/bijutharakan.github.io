<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solar System Simulation</title>
    <!-- Google Analytics -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-5RHTMQ481Q"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-5RHTMQ481Q"); // Replace with your Measurement ID
    </script>
    <link rel="manifest" href="./manifest.json" />
    <meta name="theme-color" content="#000000" />
    <link rel="apple-touch-icon" href=./favicon/apple-touch-icon.png" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>

    <script>
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("./service-worker.js")
            .then((reg) => console.log("✅ Service Worker Registered", reg))
            .catch((err) =>
              console.log("❌ Service Worker Registration Failed", err)
            );
        });
      }
    </script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }

      canvas {
        display: block;
        background: black;
      }
    </style>
  </head>

  <body>
    <script>
      let isPaused = false; // Track whether animation is paused
      let simulationSpeed = 1.0; // Speed multiplier for simulation

      let scene = new THREE.Scene();
      let camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        50000  // Increased far plane for better distant visibility
      );
      let renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softens shadows

      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      let textureLoader = new THREE.TextureLoader();

      // Ambient Light
      let ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
      scene.add(ambientLight);

      const sunLight = new THREE.PointLight(0xffffff, 2, 1300);
      sunLight.position.set(0, 0, 0);
      sunLight.shadow.mapSize.width = 4096;
      sunLight.shadow.mapSize.height = 4096;
      sunLight.shadow.camera.near = 1;
      sunLight.shadow.camera.far = 25000;
      sunLight.shadow.camera.left = -5000;
      sunLight.shadow.camera.right = 5000;
      sunLight.shadow.camera.top = 5000;
      sunLight.shadow.camera.bottom = -5000;
      sunLight.shadow.bias = -0.0005;
      scene.add(sunLight);

      let groundGeometry = new THREE.PlaneGeometry(20000, 20000);
      let groundMaterial = new THREE.ShadowMaterial({ opacity: 0.5 });
      let ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.position.y = -100;
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Improved Background with Milky Way effect
      function createSpaceBackground() {
        // Add more varied stars
        const starGroups = [
          { count: 10000, size: 0.5, color: 0xffffff, distance: 20000 },
          { count: 5000, size: 1.0, color: 0xffffcc, distance: 15000 },
          { count: 2000, size: 1.5, color: 0xccccff, distance: 18000 },
          { count: 500, size: 2.5, color: 0xffcccc, distance: 25000 }
        ];
        
        starGroups.forEach(group => {
          const geometry = new THREE.BufferGeometry();
          const vertices = [];
          const colors = [];
          
          for (let i = 0; i < group.count; i++) {
            // Create spherical distribution
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = group.distance + (Math.random() - 0.5) * 5000;
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            
            vertices.push(x, y, z);
            
            // Add color variation
            const color = new THREE.Color(group.color);
            const brightness = 0.5 + Math.random() * 0.5;
            colors.push(color.r * brightness, color.g * brightness, color.b * brightness);
          }
          
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
          geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
          
          const material = new THREE.PointsMaterial({
            size: group.size,
            vertexColors: true,
            transparent: true,
            opacity: 0.8 + Math.random() * 0.2
          });
          
          const stars = new THREE.Points(geometry, material);
          scene.add(stars);
        });
        
        // Add nebula clouds
        const nebulaTexture = new THREE.TextureLoader().load(
          'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='
        );
        
        for (let i = 0; i < 20; i++) {
          const size = 500 + Math.random() * 1000;
          const geometry = new THREE.PlaneGeometry(size, size);
          const material = new THREE.MeshBasicMaterial({
            map: nebulaTexture,
            color: new THREE.Color().setHSL(Math.random(), 0.5, 0.5),
            transparent: true,
            opacity: 0.02 + Math.random() * 0.03,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
          });
          
          const nebula = new THREE.Mesh(geometry, material);
          nebula.position.set(
            (Math.random() - 0.5) * 30000,
            (Math.random() - 0.5) * 30000,
            (Math.random() - 0.5) * 30000
          );
          nebula.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );
          
          scene.add(nebula);
        }
      }
      
      createSpaceBackground();

      function createLabeledObject(name, size, texturePath, emissiveColor) {
        let geometry = new THREE.SphereGeometry(size, 64, 64);
        let material = new THREE.MeshStandardMaterial({
          map: textureLoader.load(texturePath),
          roughness: 0.8, // less rough = more pronounced highlight
          metalness: 0.0,
          emissive: emissiveColor,
          emissiveIntensity: name == "Sun" ? 2 : 0.3,
        });
        let planet = new THREE.Mesh(geometry, material);
        planet.name = name;
        if (planet.name === "Sun") {
          planet.castShadow = false;
          planet.receiveShadow = false;
        } else {
          planet.castShadow = true;
          planet.receiveShadow = true;
        }

        let labelDiv = document.createElement("div");
        labelDiv.style.position = "absolute";
        labelDiv.style.color = "white";
        labelDiv.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
        labelDiv.style.padding = "4px";
        labelDiv.style.fontSize = "12px";
        labelDiv.innerHTML = name;
        document.body.appendChild(labelDiv);

        planet.label = labelDiv;

        return planet;
      }

      // Sun with rotation
      let sun = createLabeledObject("Sun", 180, "./img/sun.jpg", 0xff4500);
      scene.add(sun);

      // Function to add rings (for Saturn)
      function createRings(
        planet,
        innerRadius,
        outerRadius,
        texturePath,
        tiltAngle
      ) {
        let segments = 64;
        let ringGeometry = new THREE.BufferGeometry();
        let positions = [];
        let uvs = [];
        let indices = [];

        for (let i = 0; i <= segments; i++) {
          let angle = (i / segments) * Math.PI * 2;
          let xInner = innerRadius * Math.cos(angle);
          let zInner = innerRadius * Math.sin(angle);
          let xOuter = outerRadius * Math.cos(angle);
          let zOuter = outerRadius * Math.sin(angle);

          positions.push(xInner, 0, zInner, xOuter, 0, zOuter);
          uvs.push(i / segments, 0, i / segments, 1);

          if (i < segments) {
            let base = i * 2;
            indices.push(
              base,
              base + 1,
              base + 2,
              base + 1,
              base + 3,
              base + 2
            );
          }
        }

        ringGeometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        ringGeometry.setAttribute(
          "uv",
          new THREE.Float32BufferAttribute(uvs, 2)
        );
        ringGeometry.setIndex(indices);

        let ringMaterial = new THREE.MeshBasicMaterial({
          map: textureLoader.load(texturePath),
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.5, // Adjust opacity for realism
        });

        let ring = new THREE.Mesh(ringGeometry, ringMaterial);

        // ✅ Apply proper tilt angles to rings
        ring.rotation.x = tiltAngle;

        planet.add(ring);
      }

      let planets = [];
      // More realistic relative sizes (scaled for visibility)
      // Sun is 109x Earth diameter, Jupiter is 11x Earth
      let planetData = [
        {
          name: "Mercury",
          size: 3.8, // 0.38x Earth
          distance: 200,
          speed: 0.004,
          texture: "./img/mercury.jpg",
          glow: "C07B41",
          moons: [],
        },
        {
          name: "Venus",
          size: 9.5, // 0.95x Earth
          distance: 245,
          speed: 0.003,
          texture: "./img/venus2.jpg",
          glow: "C07B41",
          moons: [],
        },
        {
          name: "Earth",
          size: 10, // Reference size
          distance: 290,
          speed: 0.002,
          texture: "./img/earth.jpg",
          glow: "718ff8",
          moons: [
            {
              name: "Moon",
              size: 2.7, // 0.27x Earth
              distance: 15,
              speed: 0.01,
              texture: "./img/moon.jpg",
            },
          ],
        },
        {
          name: "Mars",
          size: 5.3, // 0.53x Earth
          distance: 340,
          speed: 0.0015,
          texture: "./img/mars.jpg",
          glow: "C07B41",
          moons: [
            {
              name: "Phobos",
              size: 0.4,
              distance: 7,
              speed: 0.015,
              texture: "./img/phobos.png",
            },
            {
              name: "Deimos",
              size: 0.3,
              distance: 10,
              speed: 0.012,
              texture: "./img/deimos.png",
            },
          ],
        },
        {
          name: "Jupiter",
          size: 55, // 11x Earth (scaled down from 110 for visibility)
          distance: 510,
          speed: 0.0008,
          texture: "./img/jupiter.jpg",
          glow: "C07B41",
          rings: false,
          ringTexture: "./img/jupiter_ring2.png", // ✅ Add Jupiter's faint rings
          innerRingSize: 10,
          outerRingSize: 10,
          ringTilt: 0.05, // Slight tilt
          moons: [
            {
              name: "Io",
              size: 2.8, // Similar to Moon
              distance: 65,
              speed: 0.007,
              texture: "./img/io.png",
            },
            {
              name: "Europa",
              size: 2.4,
              distance: 72,
              speed: 0.006,
              texture: "./img/europa.png",
            },
            {
              name: "Ganymede",
              size: 4.1, // Largest moon in solar system
              distance: 80,
              speed: 0.005,
              texture: "./img/ganymede.png",
            },
            {
              name: "Callisto",
              size: 3.8,
              distance: 90,
              speed: 0.004,
              texture: "./img/callisto.png",
            },
          ],
        },
        {
          name: "Saturn",
          size: 45, // 9x Earth (scaled down from 90)
          distance: 640,
          speed: 0.0005,
          texture: "./img/saturn.jpg",
          glow: "C07B41",
          rings: true,
          ringTexture: "./img/saturn_ring.png",
          innerRingSize: 50,
          outerRingSize: 120,
          ringTilt: 0.46, // 26.7° tilt
          moons: [
            {
              name: "Titan",
              size: 4.0, // Larger than Mercury
              distance: 55,
              speed: 0.006,
              texture: "./img/titan.png",
            },
            {
              name: "Enceladus",
              size: 0.4,
              distance: 48,
              speed: 0.008,
              texture: "./img/enceladus.png",
            },
          ],
        },
        {
          name: "Uranus",
          size: 20, // 4x Earth
          distance: 850,
          speed: 0.0003,
          texture: "./img/uranus.jpg",
          glow: "C07B41",
          rings: true,
          ringTexture: "./img/uranus_ring.png", // ✅ Uranus rings tilted
          innerRingSize: 25,
          outerRingSize: 40,
          ringTilt: 1.71, // 98° tilt (almost sideways)
          moons: [],
        },
        {
          name: "Neptune",
          size: 19.5, // 3.9x Earth
          distance: 990,
          speed: 0.0002,
          texture: "./img/neptune.jpg",
          glow: "718ff8",
          rings: true,
          ringTexture: "./img/neptune_ring.png", // ✅ Neptune's faint rings
          innerRingSize: 24,
          outerRingSize: 38,
          ringTilt: 0.49, // 28.3° tilt
          moons: [
            {
              name: "Triton",
              size: 2.1,
              distance: 25,
              speed: 0.007,
              texture: "./img/triton.png",
            },
          ],
        },
      ];
      function createMoon(parentPlanet, moonData) {
        let moonGeometry = new THREE.SphereGeometry(moonData.size, 32, 32);
        let moonMaterial = new THREE.MeshStandardMaterial({
          map: textureLoader.load(moonData.texture),
        });
        let moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.name = moonData.name;
        moon.castShadow = true;
        moon.receiveShadow = true;

        // ✅ Set moon’s initial position relative to the planet
        let moonInitialPosition = new THREE.Vector3(moonData.distance, 0, 0);
        moon.position.copy(moonInitialPosition);

        scene.add(moon);

        return {
          mesh: moon,
          speed: moonData.speed,
          distance: moonData.distance,
          angle: Math.random() * Math.PI * 2,
        };
      }

      planetData.forEach((data) => {
        let planet = createLabeledObject(
          data.name,
          data.size,
          data.texture,
          data.glow
        );


        scene.add(planet);
        // Removed debug box helper
        let planetObject = {
          name: data.name,
          mesh: planet,
          speed: data.speed,
          distance: data.distance,
          angle: Math.random() * Math.PI * 2,
          moons: [],
        };

        if (data.moons) {
          data.moons.forEach((moonData) => {
            let moon = createMoon(planetObject, moonData);
            planetObject.moons.push(moon);
          });
        }

        planets.push(planetObject);

        if (data.rings) {
          createRings(
            planet,
            data.size * 1.5,
            data.size * 2.5,
            data.ringTexture,
            data.ringTilt,
            data.innerRingSize,
            data.outerRingSize
          );
        }
      });

      // Create Asteroid Belt between Mars and Jupiter
      let asteroids = [];
      function createAsteroidBelt() {
        const numAsteroids = 500; // Number of asteroids
        const innerRadius = 380; // Just beyond Mars orbit (340)
        const outerRadius = 480; // Before Jupiter orbit (510)
        
        // Create asteroid geometry (reuse for performance)
        const asteroidGeometry = new THREE.IcosahedronGeometry(1, 0);
        const asteroidMaterial = new THREE.MeshStandardMaterial({
          color: 0x808080,
          roughness: 0.9,
          metalness: 0.1
        });
        
        for (let i = 0; i < numAsteroids; i++) {
          // Random position in the belt
          const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
          const angle = Math.random() * Math.PI * 2;
          const y = (Math.random() - 0.5) * 20; // Slight vertical spread
          
          // Random size
          const size = 0.5 + Math.random() * 2;
          
          // Create asteroid
          const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial.clone());
          asteroid.scale.set(size, size * 0.8, size * 1.2); // Irregular shape
          asteroid.position.set(
            radius * Math.cos(angle),
            y,
            radius * Math.sin(angle)
          );
          
          // Random rotation
          asteroid.rotation.set(
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2
          );
          
          asteroid.castShadow = true;
          asteroid.receiveShadow = true;
          
          scene.add(asteroid);
          
          // Store asteroid data for animation
          asteroids.push({
            mesh: asteroid,
            radius: radius,
            angle: angle,
            speed: 0.0001 + Math.random() * 0.0003, // Varying speeds
            rotationSpeed: {
              x: (Math.random() - 0.5) * 0.01,
              y: (Math.random() - 0.5) * 0.01,
              z: (Math.random() - 0.5) * 0.01
            },
            yOffset: y
          });
        }
      }
      
      createAsteroidBelt();

      // Halley's Comet removed per user request
      let halleysComet = null;
      function createHalleysComet() {
        // Comet head
        const cometGeometry = new THREE.SphereGeometry(3, 16, 16);
        const cometMaterial = new THREE.MeshStandardMaterial({
          color: 0xaaaaff,
          emissive: 0x4444ff,
          emissiveIntensity: 0.5,
          roughness: 0.3
        });
        
        const comet = new THREE.Mesh(cometGeometry, cometMaterial);
        comet.castShadow = true;
        comet.receiveShadow = true;
        
        // Comet tail (particle system)
        const tailGeometry = new THREE.BufferGeometry();
        const tailParticles = 1000;
        const tailPositions = new Float32Array(tailParticles * 3);
        const tailColors = new Float32Array(tailParticles * 3);
        const tailSizes = new Float32Array(tailParticles);
        
        for (let i = 0; i < tailParticles; i++) {
          tailPositions[i * 3] = 0;
          tailPositions[i * 3 + 1] = 0;
          tailPositions[i * 3 + 2] = 0;
          
          const intensity = 1 - (i / tailParticles);
          tailColors[i * 3] = 0.7 + intensity * 0.3;
          tailColors[i * 3 + 1] = 0.7 + intensity * 0.3;
          tailColors[i * 3 + 2] = 1;
          
          tailSizes[i] = Math.random() * 2 + 0.5;
        }
        
        tailGeometry.setAttribute('position', new THREE.BufferAttribute(tailPositions, 3));
        tailGeometry.setAttribute('color', new THREE.BufferAttribute(tailColors, 3));
        tailGeometry.setAttribute('size', new THREE.BufferAttribute(tailSizes, 1));
        
        const tailMaterial = new THREE.PointsMaterial({
          size: 2,
          vertexColors: true,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending
        });
        
        const tail = new THREE.Points(tailGeometry, tailMaterial);
        scene.add(tail);
        
        scene.add(comet);
        
        halleysComet = {
          mesh: comet,
          tail: tail,
          // Elliptical orbit parameters
          semiMajorAxis: 1800, // Semi-major axis
          semiMinorAxis: 400,  // Semi-minor axis  
          eccentricity: 0.967, // Halley's comet eccentricity
          angle: 0,
          speed: 0.0001,
          tailPositions: tailPositions,
          previousPositions: []
        };
      }
      
      // createHalleysComet(); // Disabled per user request

      let controls = new THREE.OrbitControls(camera, renderer.domElement);
      camera.position.set(0, 0, 1000);
      // Allow getting extremely close to planets to see surface details
      controls.minDistance = 0.5; // Can get super close to any object
      controls.maxDistance = 50000; // Can zoom out to see entire system
      controls.enableDamping = true; // Smooth camera movement
      controls.dampingFactor = 0.05;
      controls.panSpeed = 0.5;
      controls.rotateSpeed = 0.5;
      controls.update();

      let targetObject = null; // Stores the object (planet/moon) to follow
      let isFollowing = false; // Toggle flag for following mode
      let followOffset = new THREE.Vector3(); // Store camera offset from target
      let userControlling = false; // Track if user is controlling camera
      let defaultCameraPosition = new THREE.Vector3(0, 200, 1000); // Initial camera position

      let activeButton = null; // Track active button

      function toggleFollowObject(objectMesh, button) {
        if (targetObject === objectMesh && isFollowing) {
          resetCameraPosition();
          return;
        }

        targetObject = objectMesh;
        isFollowing = true;
        userControlling = false;

        let targetPosition = new THREE.Vector3();
        objectMesh.getWorldPosition(targetPosition);

        // Set initial offset based on object type and size
        let objectSize = objectMesh.geometry.parameters.radius || 10;
        let distance = Math.max(objectSize * 4, 50);
        
        // Start from a nice viewing angle
        followOffset.set(-distance, distance * 0.5, -distance);

        camera.position.copy(targetPosition.clone().add(followOffset));
        controls.target.copy(targetPosition);

        // Allow extremely close zoom to see planet surface details
        controls.minDistance = objectSize * 0.1; // Get super close to surface
        controls.maxDistance = objectSize * 100; // Can still go far
        controls.enableZoom = true;
        controls.enableRotate = true;
        controls.enablePan = false; // Disable panning while following

        controls.update();

        console.log("Camera moved to:", camera.position);

        // ✅ Update button UI
        if (activeButton) {
          activeButton.style.background = activeButton.dataset.originalBg || "rgba(255,255,255,0.1)";
          activeButton.style.color = activeButton.dataset.originalColor || "#fff";
          activeButton.style.borderColor = activeButton.dataset.originalBorder || "rgba(255,255,255,0.3)";
          activeButton.innerText = activeButton.dataset.name;
        }

        activeButton = button;
        button.dataset.originalBg = button.style.background;
        button.dataset.originalColor = button.style.color;
        button.dataset.originalBorder = button.style.borderColor;
        button.style.background = "rgba(76, 175, 80, 0.4)";
        button.style.borderColor = "#4CAF50";
        button.style.color = "#90ee90";
        button.innerText = `▶ ${objectMesh.name}`;
      }

      function resetCameraPosition() {
        targetObject = null;
        isFollowing = false;
        camera.position.copy(defaultCameraPosition);
        controls.target.set(0, 0, 0);

        // ✅ Reset zoom limits - allow very close and very far
        controls.minDistance = 0.5; // Allow extreme close-ups
        controls.maxDistance = 50000; // See entire solar system
        controls.enableZoom = true; // Ensure zoom works after reset

        controls.update();

        // Reset active button UI
        if (activeButton) {
          activeButton.style.background = activeButton.dataset.originalBg || "rgba(255,255,255,0.1)";
          activeButton.style.color = activeButton.dataset.originalColor || "#fff";
          activeButton.style.borderColor = activeButton.dataset.originalBorder || "rgba(255,255,255,0.3)";
          activeButton.innerText = activeButton.dataset.name;
          activeButton = null;
        }
      }
      function animate() {
        requestAnimationFrame(animate);

        if (!isPaused) {
          sun.rotation.y += 0.002; // Rotate the Sun

          planets.forEach((planet) => {
            planet.angle += planet.speed * simulationSpeed;
            planet.mesh.position.x = planet.distance * Math.cos(planet.angle);
            planet.mesh.position.z = planet.distance * Math.sin(planet.angle);

            if (planetRotationSpeeds[planet.name]) {
              planet.mesh.rotation.y += planetRotationSpeeds[planet.name];
            }

            planet.moons.forEach((moon) => {
              moon.angle += moon.speed * simulationSpeed;
              let moonX = moon.distance * Math.cos(moon.angle);
              let moonZ = moon.distance * Math.sin(moon.angle);
              let planetPosition = planet.mesh.position;

              moon.mesh.position.set(
                planetPosition.x + moonX,
                planetPosition.y,
                planetPosition.z + moonZ
              );

              moon.mesh.rotation.y += 0.02; // Moon self-rotation
            });

            // Update planet labels position
            let vector = new THREE.Vector3();
            planet.mesh.getWorldPosition(vector);
            let coords = vector.project(camera);
            let x = (coords.x * 0.5 + 0.5) * window.innerWidth;
            let y = (coords.y * -0.5 + 0.5) * window.innerHeight;
            planet.mesh.label.style.transform = `translate(${x}px, ${y}px)`;
          });

          // Animate asteroids
          asteroids.forEach(asteroid => {
            // Orbit around sun
            asteroid.angle += asteroid.speed * simulationSpeed;
            asteroid.mesh.position.x = asteroid.radius * Math.cos(asteroid.angle);
            asteroid.mesh.position.z = asteroid.radius * Math.sin(asteroid.angle);
            asteroid.mesh.position.y = asteroid.yOffset;
            
            // Rotate asteroid
            asteroid.mesh.rotation.x += asteroid.rotationSpeed.x * simulationSpeed;
            asteroid.mesh.rotation.y += asteroid.rotationSpeed.y * simulationSpeed;
            asteroid.mesh.rotation.z += asteroid.rotationSpeed.z * simulationSpeed;
          });
          
          // Halley's Comet animation disabled
          if (false && halleysComet) {
            halleysComet.angle += halleysComet.speed * simulationSpeed;
            
            // Elliptical orbit calculation
            const a = halleysComet.semiMajorAxis;
            const b = halleysComet.semiMinorAxis;
            const x = a * Math.cos(halleysComet.angle);
            const z = b * Math.sin(halleysComet.angle);
            
            halleysComet.mesh.position.set(x, 0, z);
            
            // Store previous positions for tail
            halleysComet.previousPositions.unshift({x, y: 0, z});
            if (halleysComet.previousPositions.length > 1000) {
              halleysComet.previousPositions.pop();
            }
            
            // Update tail positions
            const positions = halleysComet.tail.geometry.attributes.position.array;
            for (let i = 0; i < Math.min(halleysComet.previousPositions.length, 1000); i++) {
              const pos = halleysComet.previousPositions[i];
              const spread = i * 0.1;
              positions[i * 3] = pos.x + (Math.random() - 0.5) * spread;
              positions[i * 3 + 1] = pos.y + (Math.random() - 0.5) * spread;
              positions[i * 3 + 2] = pos.z + (Math.random() - 0.5) * spread;
            }
            halleysComet.tail.geometry.attributes.position.needsUpdate = true;
          }

          // 🚀 Ensure camera follows the selected object (planet or moon)
          if (isFollowing && targetObject) {
            // Find if it's a planet
            let targetPlanet = planets.find(p => p.mesh === targetObject);
            
            if (targetPlanet) {
              updateCameraFollow(targetPlanet);
            } else {
              // Check if it's a moon
              for (let planet of planets) {
                let targetMoon = planet.moons.find(m => m.mesh === targetObject);
                if (targetMoon) {
                  updateCameraFollow(targetMoon);
                  break;
                }
              }
            }
          }
        }

        controls.update();
        renderer.render(scene, camera);
      }
      // const shadowCameraHelper = new THREE.CameraHelper(sunLight.shadow.camera);
      // scene.add(shadowCameraHelper);

      let planetTilts = {
        Mercury: 0.0349, // 7 degrees
        Venus: 3.096, // 177 degrees (Retrograde)
        Earth: 0.4091, // 23.4 degrees
        Mars: 0.4396, // 25 degrees
        Jupiter: 0.0546, // 3 degrees
        Saturn: 0.4665, // 26.7 degrees
        Uranus: 1.706, // 98 degrees (Retrograde)
        Neptune: 0.4943, // 28.3 degrees
      };

      let planetRotationSpeeds = {
        Mercury: 0.0005,
        Venus: -0.0008, // Venus rotates backwards (Retrograde)
        Earth: 0.008,
        Mars: 0.0025,
        Jupiter: 0.005,
        Saturn: 0.004,
        Uranus: -0.003, // Uranus rotates sideways (Retrograde)
        Neptune: 0.004,
      };

      // Apply Tilt to Planets
      planets.forEach((planet) => {
        if (planetTilts[planet.name]) {
          planet.mesh.rotation.z = planetTilts[planet.name]; // Apply axial tilt
        }
      });

      let controlsContainer = document.createElement("div");
      controlsContainer.style.position = "absolute";
      controlsContainer.style.top = "10px";
      controlsContainer.style.left = "10px";
      controlsContainer.style.zIndex = "100";
      controlsContainer.style.background = "rgba(0, 0, 0, 0.8)";
      controlsContainer.style.padding = "15px";
      controlsContainer.style.borderRadius = "10px";
      controlsContainer.style.maxWidth = "250px";
      controlsContainer.style.maxHeight = "90vh";
      controlsContainer.style.overflowY = "auto";
      controlsContainer.style.backdropFilter = "blur(10px)";
      document.body.appendChild(controlsContainer);
      
      // Add title
      let title = document.createElement("h3");
      title.innerText = "Solar System Controls";
      title.style.color = "#fff";
      title.style.margin = "0 0 10px 0";
      title.style.fontSize = "16px";
      title.style.borderBottom = "1px solid rgba(255,255,255,0.3)";
      title.style.paddingBottom = "8px";
      controlsContainer.appendChild(title);

      // Create buttons for each planet with better organization
      function createPlanetButton(planet, index) {
        // Create planet container
        let planetContainer = document.createElement("div");
        planetContainer.style.marginBottom = "8px";
        
        let button = document.createElement("button");
        button.innerText = planet.name;
        button.dataset.name = planet.name;
        button.style.width = "100%";
        button.style.padding = "8px";
        button.style.cursor = "pointer";
        button.style.border = "1px solid rgba(255,255,255,0.3)";
        button.style.background = "rgba(255,255,255,0.1)";
        button.style.color = "#fff";
        button.style.borderRadius = "5px";
        button.style.fontSize = "14px";
        button.style.transition = "all 0.3s";
        
        button.addEventListener("mouseenter", () => {
          if (button !== activeButton) {
            button.style.background = "rgba(255,255,255,0.2)";
          }
        });
        
        button.addEventListener("mouseleave", () => {
          if (button !== activeButton) {
            button.style.background = "rgba(255,255,255,0.1)";
          }
        });

        button.addEventListener("click", () =>
          toggleFollowObject(planets[index].mesh, button)
        );
        planetContainer.appendChild(button);

        // Create moon buttons container
        if (planet.moons && planet.moons.length > 0) {
          let moonContainer = document.createElement("div");
          moonContainer.style.marginLeft = "20px";
          moonContainer.style.marginTop = "4px";
          
          planet.moons.forEach((moon) => {
            if (moon && moon.mesh) {
              let moonButton = document.createElement("button");
              moonButton.innerText = moon.mesh.name || moon.name;
              moonButton.dataset.name = `${planet.name} - ${
                moon.mesh.name || moon.name
              }`;
              moonButton.style.width = "calc(100% - 10px)";
              moonButton.style.padding = "6px";
              moonButton.style.marginBottom = "3px";
              moonButton.style.cursor = "pointer";
              moonButton.style.border = "1px solid rgba(255,255,255,0.2)";
              moonButton.style.background = "rgba(255,255,255,0.05)";
              moonButton.style.color = "#ccc";
              moonButton.style.borderRadius = "3px";
              moonButton.style.fontSize = "12px";
              moonButton.style.transition = "all 0.3s";
              
              moonButton.addEventListener("mouseenter", () => {
                if (moonButton !== activeButton) {
                  moonButton.style.background = "rgba(255,255,255,0.15)";
                }
              });
              
              moonButton.addEventListener("mouseleave", () => {
                if (moonButton !== activeButton) {
                  moonButton.style.background = "rgba(255,255,255,0.05)";
                }
              });

              moonButton.addEventListener("click", () =>
                toggleFollowObject(moon.mesh, moonButton)
              );
              moonContainer.appendChild(moonButton);
            }
          });
          planetContainer.appendChild(moonContainer);
        }
        
        controlsContainer.appendChild(planetContainer);
      }

      // Add control section
      let controlSection = document.createElement("div");
      controlSection.style.marginBottom = "15px";
      controlSection.style.paddingBottom = "10px";
      controlSection.style.borderBottom = "1px solid rgba(255,255,255,0.2)";
      
      // 🚀 Add Pause/Resume Button
      let pauseButton = document.createElement("button");
      pauseButton.innerText = "⏸ Pause";
      pauseButton.style.width = "48%";
      pauseButton.style.padding = "8px";
      pauseButton.style.marginRight = "4%";
      pauseButton.style.cursor = "pointer";
      pauseButton.style.border = "1px solid #007BFF";
      pauseButton.style.background = "rgba(0, 123, 255, 0.2)";
      pauseButton.style.color = "#4da6ff";
      pauseButton.style.borderRadius = "5px";
      pauseButton.style.fontSize = "13px";
      pauseButton.style.transition = "all 0.3s";
      pauseButton.addEventListener("click", () => {
        isPaused = !isPaused;
        pauseButton.innerText = isPaused ? "▶ Resume" : "⏸ Pause";
        pauseButton.style.background = isPaused ? "rgba(40, 167, 69, 0.2)" : "rgba(0, 123, 255, 0.2)";
        pauseButton.style.borderColor = isPaused ? "#28a745" : "#007BFF";
        pauseButton.style.color = isPaused ? "#5cb85c" : "#4da6ff";
      });
      controlSection.appendChild(pauseButton);

      // 🚀 Add Reset Button
      let resetButton = document.createElement("button");
      resetButton.innerText = "🔄 Reset";
      resetButton.style.width = "48%";
      resetButton.style.padding = "8px";
      resetButton.style.cursor = "pointer";
      resetButton.style.border = "1px solid #dc3545";
      resetButton.style.background = "rgba(220, 53, 69, 0.2)";
      resetButton.style.color = "#ff6b7a";
      resetButton.style.borderRadius = "5px";
      resetButton.style.fontSize = "13px";
      resetButton.style.transition = "all 0.3s";
      resetButton.addEventListener("click", resetCameraPosition);
      controlSection.appendChild(resetButton);
      
      controlsContainer.appendChild(controlSection);
      
      // Add speed control section
      let speedSection = document.createElement("div");
      speedSection.style.marginBottom = "15px";
      speedSection.style.paddingBottom = "10px";
      speedSection.style.borderBottom = "1px solid rgba(255,255,255,0.2)";
      
      let speedLabel = document.createElement("div");
      speedLabel.innerText = "Simulation Speed";
      speedLabel.style.color = "#aaa";
      speedLabel.style.fontSize = "12px";
      speedLabel.style.marginBottom = "8px";
      speedLabel.style.textTransform = "uppercase";
      speedLabel.style.letterSpacing = "1px";
      speedSection.appendChild(speedLabel);
      
      // Speed control buttons
      let speedContainer = document.createElement("div");
      speedContainer.style.display = "flex";
      speedContainer.style.gap = "5px";
      speedContainer.style.marginBottom = "5px";
      
      const speeds = [
        { label: "0.5x", value: 0.5 },
        { label: "1x", value: 1 },
        { label: "2x", value: 2 },
        { label: "5x", value: 5 },
        { label: "10x", value: 10 }
      ];
      
      speeds.forEach(speed => {
        let btn = document.createElement("button");
        btn.innerText = speed.label;
        btn.style.flex = "1";
        btn.style.padding = "6px";
        btn.style.cursor = "pointer";
        btn.style.border = "1px solid rgba(255,255,255,0.2)";
        btn.style.background = speed.value === 1 ? "rgba(0, 123, 255, 0.3)" : "rgba(255,255,255,0.05)";
        btn.style.color = speed.value === 1 ? "#4da6ff" : "#aaa";
        btn.style.borderRadius = "3px";
        btn.style.fontSize = "11px";
        btn.style.transition = "all 0.3s";
        
        btn.addEventListener("click", () => {
          simulationSpeed = speed.value;
          // Update all buttons
          speedContainer.querySelectorAll("button").forEach(b => {
            b.style.background = "rgba(255,255,255,0.05)";
            b.style.color = "#aaa";
            b.style.borderColor = "rgba(255,255,255,0.2)";
          });
          btn.style.background = "rgba(0, 123, 255, 0.3)";
          btn.style.color = "#4da6ff";
          btn.style.borderColor = "#007BFF";
        });
        
        speedContainer.appendChild(btn);
      });
      
      speedSection.appendChild(speedContainer);
      
      // Current speed display
      let speedDisplay = document.createElement("div");
      speedDisplay.innerText = "Current: 1x";
      speedDisplay.style.color = "#888";
      speedDisplay.style.fontSize = "11px";
      speedDisplay.style.textAlign = "center";
      speedSection.appendChild(speedDisplay);
      
      // Update speed display
      setInterval(() => {
        speedDisplay.innerText = `Current: ${simulationSpeed}x`;
      }, 100);
      
      controlsContainer.appendChild(speedSection);
      
      // Add camera view modes section
      let viewSection = document.createElement("div");
      viewSection.style.marginBottom = "15px";
      viewSection.style.paddingBottom = "10px";
      viewSection.style.borderBottom = "1px solid rgba(255,255,255,0.2)";
      
      let viewLabel = document.createElement("div");
      viewLabel.innerText = "Camera Views";
      viewLabel.style.color = "#aaa";
      viewLabel.style.fontSize = "12px";
      viewLabel.style.marginBottom = "8px";
      viewLabel.style.textTransform = "uppercase";
      viewLabel.style.letterSpacing = "1px";
      viewSection.appendChild(viewLabel);
      
      // Camera view buttons
      const cameraViews = [
        { label: "🌍 From Moon", action: () => setViewFromMoon() },
        { label: "☀️ Solar View", action: () => setSolarSystemView() },
        { label: "🚀 Orbit View", action: () => setOrbitView() },
        { label: "🌌 Galaxy View", action: () => setGalaxyView() }
      ];
      
      cameraViews.forEach(view => {
        let btn = document.createElement("button");
        btn.innerText = view.label;
        btn.style.width = "48%";
        btn.style.margin = "2px 1%";
        btn.style.padding = "8px";
        btn.style.cursor = "pointer";
        btn.style.border = "1px solid rgba(255,255,255,0.2)";
        btn.style.background = "rgba(255,255,255,0.05)";
        btn.style.color = "#aaa";
        btn.style.borderRadius = "3px";
        btn.style.fontSize = "11px";
        btn.style.transition = "all 0.3s";
        
        btn.addEventListener("click", view.action);
        btn.addEventListener("mouseenter", () => {
          btn.style.background = "rgba(255,255,255,0.15)";
        });
        btn.addEventListener("mouseleave", () => {
          btn.style.background = "rgba(255,255,255,0.05)";
        });
        
        viewSection.appendChild(btn);
      });
      
      controlsContainer.appendChild(viewSection);
      
      // Camera view functions
      function setViewFromMoon() {
        // Find Earth and its moon
        const earth = planets.find(p => p.name === "Earth");
        if (earth && earth.moons.length > 0) {
          const moon = earth.moons[0];
          const moonPos = moon.mesh.position;
          const earthPos = earth.mesh.position;
          
          // Position camera on moon looking at Earth
          camera.position.copy(moonPos);
          camera.position.y += 5;
          controls.target.copy(earthPos);
          
          targetObject = null;
          isFollowing = false;
          controls.update();
        }
      }
      
      function setSolarSystemView() {
        // Top-down view of solar system
        camera.position.set(0, 2000, 0);
        controls.target.set(0, 0, 0);
        targetObject = null;
        isFollowing = false;
        controls.update();
      }
      
      function setOrbitView() {
        // Angled orbital view
        camera.position.set(800, 600, 800);
        controls.target.set(0, 0, 0);
        targetObject = null;
        isFollowing = false;
        controls.update();
      }
      
      function setGalaxyView() {
        // Far out galaxy view
        camera.position.set(3000, 2000, 3000);
        controls.target.set(0, 0, 0);
        targetObject = null;
        isFollowing = false;
        controls.update();
      }
      
      // Add celestial bodies section label
      let bodiesLabel = document.createElement("div");
      bodiesLabel.innerText = "Celestial Bodies";
      bodiesLabel.style.color = "#aaa";
      bodiesLabel.style.fontSize = "12px";
      bodiesLabel.style.marginBottom = "8px";
      bodiesLabel.style.textTransform = "uppercase";
      bodiesLabel.style.letterSpacing = "1px";
      controlsContainer.appendChild(bodiesLabel);

      // Create a button for the Sun
      let sunButton = document.createElement("button");
      sunButton.innerText = "☀ Sun";
      sunButton.style.width = "100%";
      sunButton.style.padding = "10px";
      sunButton.style.marginBottom = "10px";
      sunButton.style.cursor = "pointer";
      sunButton.style.border = "1px solid #ff6600";
      sunButton.style.background = "rgba(255, 102, 0, 0.3)";
      sunButton.style.color = "#ffaa44";
      sunButton.style.borderRadius = "5px";
      sunButton.style.fontSize = "14px";
      sunButton.style.fontWeight = "bold";
      sunButton.style.transition = "all 0.3s";
      sunButton.addEventListener("mouseenter", () => {
        sunButton.style.background = "rgba(255, 102, 0, 0.5)";
      });
      sunButton.addEventListener("mouseleave", () => {
        sunButton.style.background = "rgba(255, 102, 0, 0.3)";
      });
      sunButton.addEventListener("click", () => moveCameraTo(sun));
      controlsContainer.appendChild(sunButton);

      planetData.forEach((planet, index) => {
        createPlanetButton(planet, index);
      });

      // 🚀 Add Toggle Controls Button
      let toggleControlsButton = document.createElement("button");
      toggleControlsButton.innerText = "◀ Hide";
      toggleControlsButton.style.padding = "8px 12px";
      toggleControlsButton.style.cursor = "pointer";
      toggleControlsButton.style.border = "1px solid rgba(255,255,255,0.3)";
      toggleControlsButton.style.background = "rgba(0, 0, 0, 0.8)";
      toggleControlsButton.style.color = "#fff";
      toggleControlsButton.style.borderRadius = "5px";
      toggleControlsButton.style.position = "absolute";
      toggleControlsButton.style.top = "10px";
      toggleControlsButton.style.right = "10px";
      toggleControlsButton.style.zIndex = "101";
      toggleControlsButton.style.fontSize = "13px";
      toggleControlsButton.style.backdropFilter = "blur(10px)";
      toggleControlsButton.style.transition = "all 0.3s";
      document.body.appendChild(toggleControlsButton);

      toggleControlsButton.addEventListener("mouseenter", () => {
        toggleControlsButton.style.background = "rgba(0, 0, 0, 0.9)";
        toggleControlsButton.style.borderColor = "rgba(255,255,255,0.5)";
      });
      
      toggleControlsButton.addEventListener("mouseleave", () => {
        toggleControlsButton.style.background = "rgba(0, 0, 0, 0.8)";
        toggleControlsButton.style.borderColor = "rgba(255,255,255,0.3)";
      });

      toggleControlsButton.addEventListener("click", () => {
        if (controlsContainer.style.display === "none") {
          controlsContainer.style.display = "block";
          toggleControlsButton.innerText = "◀ Hide";
        } else {
          controlsContainer.style.display = "none";
          toggleControlsButton.innerText = "▶ Show";
        }
      });

      function updateCameraFollow(targetObject) {
        if (!targetObject || !targetObject.mesh) return;
        
        // Get the current world position of the target
        let targetPosition = new THREE.Vector3();
        targetObject.mesh.getWorldPosition(targetPosition);
        
        // If user is controlling, update the offset based on current camera position
        if (userControlling) {
          followOffset.copy(camera.position).sub(targetPosition);
        }
        
        // Apply the offset to follow the target
        let desiredCamPos = targetPosition.clone().add(followOffset);
        
        // Smooth camera movement
        camera.position.lerp(desiredCamPos, 0.15);
        controls.target.lerp(targetPosition, 0.15);
        
        controls.update();
      }
      
      // Detect when user starts controlling the camera
      controls.addEventListener('start', function() {
        if (isFollowing) {
          userControlling = true;
        }
      });
      
      controls.addEventListener('change', function() {
        if (isFollowing && userControlling) {
          // Update offset while user is controlling
          if (targetObject) {
            let targetPosition = new THREE.Vector3();
            targetObject.getWorldPosition(targetPosition);
            followOffset.copy(camera.position).sub(targetPosition);
          }
        }
      });

      function moveCameraTo(target) {
        console.log(`Moving camera to: ${target.name}`);

        let targetPosition = new THREE.Vector3();
        target.getWorldPosition(targetPosition);

        if (target.name === "Sun") {
          if (activeButton) {
            activeButton.style.background = "#fff";
            activeButton.style.color = "#000";
            activeButton.innerText = activeButton.dataset.name;
          }

          // View Sun from a good distance to see the whole solar system
          camera.position.set(
            targetPosition.x + 400,
            targetPosition.y + 300,
            targetPosition.z + 400
          );
          controls.target.copy(targetPosition);

          //   // Toggle Sun button: If already selected, reset camera
          //   if (activeButton === sunButton) {
          //     resetCameraPosition();
          //     return;
          //   }
        } else {
          // Regular offset for planets & moons
          let offset = target.name.toLowerCase().includes("moon")
            ? new THREE.Vector3(-15, 5, -25)
            : new THREE.Vector3(-50, 20, -100);

          camera.position.copy(targetPosition.clone().add(offset));
          controls.target.copy(targetPosition);
        }

        controls.update();

        // ✅ Reset Follow Mode when moving to Sun
        if (target.name === "Sun") {
          targetObject = null;
          isFollowing = false;
        } else {
          targetObject = target;
          isFollowing = true;
        }

        // ✅ Reset previous active button
        if (activeButton) {
          activeButton.style.background = "#fff";
          activeButton.style.color = "#000";
          activeButton.innerText = activeButton.dataset.name;
        }

        // ✅ Highlight correct button
      }

      let starTexture = textureLoader.load("./img/comet_texture.png");

      let starMaterial2 = new THREE.SpriteMaterial({
        map: starTexture,
        color: 0xffffff, // White or slightly yellowish
        transparent: true,
        opacity: 0.8,
      });

      function createStar(x, y, z, size) {
        size = size * 0.35;
        let star = new THREE.Sprite(starMaterial2);
        star.position.set(x, y, z);
        star.scale.set(size, size, 1);
        scene.add(star);
        return star;
      }

      const orionStarsData = [
        { name: "Betelgeuse", RA: 88.8, Dec: 7.4, size: 25 },
        { name: "Bellatrix", RA: 81.3, Dec: 6.3, size: 22 },
        { name: "Mintaka", RA: 78.6, Dec: -0.3, size: 20 },
        { name: "Alnilam", RA: 84.0, Dec: -1.2, size: 20 },
        { name: "Alnitak", RA: 86.1, Dec: -1.9, size: 20 },
        { name: "Saiph", RA: 86.9, Dec: -9.7, size: 22 },
        { name: "Rigel", RA: 78.6, Dec: -8.2, size: 24 },
      ];

      function createConstellation(starData, radius = 8000, color = 0xffffff, name = "") {
        let constellationStars = new THREE.Group();
        let positions = [];

        starData.forEach((star, index) => {
          let raRad = (star.RA / 24) * Math.PI * 2;
          let decRad = (star.Dec / 90) * (Math.PI / 2);

          let x = radius * Math.cos(decRad) * Math.cos(raRad);
          let y = radius * Math.sin(decRad);
          let z = radius * Math.cos(decRad) * Math.sin(raRad);

          // Create brighter, more visible stars
          let starGeometry = new THREE.SphereGeometry(star.size * 2, 16, 16);
          let starMaterial = new THREE.MeshBasicMaterial({ 
            color: color,
            emissive: color,
            emissiveIntensity: 2
          });
          let starMesh = new THREE.Mesh(starGeometry, starMaterial);
          starMesh.position.set(x, y, z);

          // Add glow effect
          let glowGeometry = new THREE.SphereGeometry(star.size * 4, 8, 8);
          let glowMaterial = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.3
          });
          let glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
          glowMesh.position.copy(starMesh.position);
          
          constellationStars.add(starMesh);
          constellationStars.add(glowMesh);
          
          positions.push(new THREE.Vector3(x, y, z));
        });

        // Add constellation lines (connect the stars)
        if (positions.length > 1 && name !== "Pleiades") {
          const lineGeometry = new THREE.BufferGeometry().setFromPoints(positions);
          const lineMaterial = new THREE.LineBasicMaterial({ 
            color: color, 
            transparent: true,
            opacity: 0.2,
            linewidth: 2
          });
          const line = new THREE.Line(lineGeometry, lineMaterial);
          constellationStars.add(line);
        }

        return constellationStars;
      }

      const bigDipperStarsData = [
        { name: "Dubhe", RA: 165.9, Dec: 61.7, size: 24 },
        { name: "Merak", RA: 165.5, Dec: 56.4, size: 22 },
        { name: "Phecda", RA: 174.3, Dec: 53.7, size: 10 },
        { name: "Megrez", RA: 178.4, Dec: 57.0, size: 10 },
        { name: "Alioth", RA: 193.5, Dec: 55.9, size: 12 },
        { name: "Mizar", RA: 200.9, Dec: 54.9, size: 12 },
        { name: "Alkaid", RA: 206.9, Dec: 49.3, size: 14 },
      ];

      const cassiopeiaStarsData = [
        { name: "Schedar", RA: 10.1, Dec: 56.5, size: 12 },
        { name: "Caph", RA: 2.3, Dec: 59.1, size: 10 },
        { name: "Gamma Cas", RA: 6.1, Dec: 60.7, size: 10 },
        { name: "Ruchbah", RA: 14.2, Dec: 59.2, size: 10 },
        { name: "Segin", RA: 18.4, Dec: 63.7, size: 10 },
      ];

      const pleiadesStarsData = [
        { name: "Alcyone", RA: 56.9, Dec: 24.1, size: 12 },
        { name: "Atlas", RA: 56.4, Dec: 23.8, size: 10 },
        { name: "Electra", RA: 56.2, Dec: 24.1, size: 10 },
        { name: "Maia", RA: 56.4, Dec: 24.2, size: 10 },
        { name: "Merope", RA: 56.1, Dec: 23.7, size: 10 },
        { name: "Taygeta", RA: 56.1, Dec: 24.4, size: 10 },
        { name: "Pleione", RA: 56.7, Dec: 24.1, size: 10 },
      ];

      // Create constellations with enhanced visibility
      let orionStars = createConstellation(orionStarsData, 12000, 0xaaaaff, "Orion");
      let bigDipperStars = createConstellation(
        bigDipperStarsData,
        13000,
        0xffffaa,
        "BigDipper"
      );
      let cassiopeiaStars = createConstellation(
        cassiopeiaStarsData,
        11000,
        0xffaaaa,
        "Cassiopeia"
      );
      let pleiadesStars = createConstellation(
        pleiadesStarsData,
        10000,
        0xaaffff,
        "Pleiades"
      );

      let backgroundStars = new THREE.Group();
      backgroundStars.add(orionStars);
      backgroundStars.add(bigDipperStars);
      backgroundStars.add(cassiopeiaStars);
      backgroundStars.add(pleiadesStars);

      scene.add(backgroundStars);

      animate();
    </script>
  </body>
</html>
